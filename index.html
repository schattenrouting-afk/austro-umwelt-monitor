<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AT Umwelt & Wetter – Bezirke + Städte</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <style>
    html, body { height: 100%; margin: 0; font-family: Arial, Helvetica, sans-serif; }
    #map { height: 100%; width: 100%; }

    .panelWrap{
      position:absolute; z-index:1000;
      top:12px; left:56px;
      display:flex; align-items:flex-start; gap:8px;
    }

    .panelToggle{
      background:rgba(255,255,255,0.95);
      border-radius:10px;
      box-shadow:0 6px 18px rgba(0,0,0,0.15);
      border:1px solid rgba(0,0,0,0.10);
      cursor:pointer;
      padding:8px 10px;
      font-size:14px;
      user-select:none;
      line-height:1;
      position:relative;
    }
    .panelToggle.pulse::after{
      content:"";
      position:absolute;
      inset:-6px;
      border-radius:12px;
      border:2px solid rgba(220,0,0,0.25);
      animation: pulse 1.6s ease-in-out infinite;
      pointer-events:none;
    }
    @keyframes pulse{
      0%   { transform:scale(0.92); opacity:0.00; }
      30%  { transform:scale(1.00); opacity:0.65; }
      70%  { transform:scale(1.05); opacity:0.30; }
      100% { transform:scale(1.10); opacity:0.00; }
    }

    .panel{
      background:rgba(255,255,255,0.95);
      border-radius:12px; padding:10px 12px;
      box-shadow:0 6px 18px rgba(0,0,0,0.15);
      border:1px solid rgba(0,0,0,0.08);
      min-width:360px;
      max-width:420px;
    }
    .panel.collapsed{ display:none; }

    .panel h1{ font-size:14px; margin:0 0 8px; }

    .activeMetric{
      font-size:12px;
      color:#222;
      background:#fff;
      border:1px solid rgba(0,0,0,0.08);
      border-radius:10px;
      padding:8px 10px;
      margin:0 0 10px;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .activeRow{
      display:flex;
      gap:8px;
      align-items:center;
      min-width:0;
    }
    .badge{
      display:inline-block;
      font-size:11px;
      padding:2px 8px;
      border-radius:999px;
      background:rgba(0,0,0,0.06);
      border:1px solid rgba(0,0,0,0.08);
      color:#222;
      white-space:nowrap;
      flex:0 0 auto;
    }
    .activeName{
      font-weight:700;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      min-width:0;
      flex:1 1 auto;
    }
    .activeSub{
      font-size:12px;
      color:#333;
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      align-items:center;
    }
    .pill{
      display:inline-block;
      font-size:11px;
      padding:2px 8px;
      border-radius:999px;
      background:rgba(0,0,0,0.04);
      border:1px solid rgba(0,0,0,0.08);
      color:#222;
      white-space:nowrap;
    }
    .pill.disabled{
      opacity:0.45;
    }

    .row{ display:flex; gap:8px; align-items:center; margin:8px 0; }
    .row label{ font-size:12px; width:120px; color:#333; }
    select, input{
      flex:1; padding:7px 9px; border:1px solid #ccc; border-radius:10px;
      font-size:13px; outline:none;
    }
    .btn{
      padding:7px 10px; border:1px solid #ccc; background:#fff;
      border-radius:10px; cursor:pointer; font-size:12px;
    }
    .btn:hover{ background:#f7f7f7; }
    .sep{ height:1px; background:#eee; margin:10px 0; }

    .sectionTitle{
      font-size:12px;
      color:#222;
      margin:10px 0 6px;
      font-weight:700;
    }

    /* Radio grids */
    .radioGrid{
      display:grid;
      grid-template-columns: 18px 1fr 18px 1fr;
      gap:8px 10px;
      align-items:center;
      margin-top:6px;
    }
    .radioGrid.oneCol{
      grid-template-columns: 18px 1fr;
    }
    .radioGrid input[type="radio"]{
      margin:0;
      transform: translateY(1px);
    }
    .radioLabel{
      font-size:12px;
      color:#222;
      line-height:1.1;
      user-select:none;
    }
    .radioLabel small{
      display:block;
      font-size:11px;
      color:#666;
      margin-top:2px;
      line-height:1.2;
    }

    .radioGrid.disabled{
      opacity:0.55;
      pointer-events:none;
    }

    .chip{ display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; color:#fff; margin:0 6px 6px 0; }
    .chip.GREY{ background:#9e9e9e; }
    .chip.GREEN{ background:#388e3c; }
    .chip.YELLOW{ background:#fbc02d; color:#222; }
    .chip.ORANGE{ background:#f57c00; }
    .chip.RED{ background:#d32f2f; }

    .popupBody{ max-height: 320px; overflow:auto; padding-right:6px; }
    .popupTable td{ vertical-align:top; }

    .cityLabel{
      background: rgba(255,255,255,0.85);
      border: 1px solid rgba(0,0,0,0.12);
      border-radius: 10px;
      padding: 2px 6px;
      font-size: 11px;
      color:#222;
      box-shadow: 0 2px 8px rgba(0,0,0,0.10);
      white-space: nowrap;
    }
    .cityLabelWrap{
      transform: translate(8px, -10px);
    }

    .modalBackdrop{
      position:fixed; inset:0; z-index:2000;
      background: rgba(0,0,0,0.35);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
    }
    .modal{
      background:#fff;
      border-radius:14px;
      box-shadow:0 10px 30px rgba(0,0,0,0.25);
      border:1px solid rgba(0,0,0,0.12);
      max-width:560px;
      width:100%;
      padding:14px 14px 12px;
    }
    .modal h2{ margin:0 0 8px; font-size:14px; }
    .modal p{ margin:8px 0; font-size:12px; line-height:1.45; color:#333; }
    .modalActions{ display:flex; justify-content:flex-end; margin-top:10px; }
    .linkBtn{
      background:transparent;
      border:none;
      padding:0;
      margin:0;
      font-size:12px;
      color:#1a73e8;
      cursor:pointer;
      text-decoration:underline;
    }
  </style>
</head>

<body>
  <div id="map"></div>

  <div class="panelWrap">
    <div class="panelToggle pulse" id="panelToggle" title="Panel ein-/ausklappen">☰</div>

    <div class="panel" id="panel">
      <h1>AT Umwelt & Wetter – Bezirke + Städte</h1>

      <div class="activeMetric">
        <div class="activeRow">
          <span class="badge">Aktiv</span>
          <span class="activeName" id="activeMetricName">Feinstaub (PM10)</span>
        </div>
        <div class="activeSub">
          <span class="pill" id="activeAggPill">Bezirkswert: Höchster Wert (Worst Case)</span>
          <span class="pill" id="activeLabelPill">Labels ab Zoom 10</span>
        </div>
      </div>

      <div class="sectionTitle">Kennzahl auswählen</div>

      <div class="sectionTitle" style="margin-top:6px;">Wetter</div>
      <div class="radioGrid" id="metricWeatherRadios"></div>

      <div class="sectionTitle">Luft (Fläche)</div>
      <div class="radioGrid" id="metricAirRadios"></div>

      <div class="sectionTitle">Pollen</div>
      <div class="radioGrid oneCol" id="metricPollenRadios"></div>

      <div class="sectionTitle">Warnstufen</div>
      <div class="radioGrid" id="metricWarnRadios"></div>

      <div class="sep"></div>

      <div class="sectionTitle">Bezirkswert (Aggregation)</div>
      <div class="radioGrid oneCol" id="aggRadios"></div>
      <div style="font-size:11px;color:#666;margin-top:6px;">
        Hinweis: Aggregation wirkt nur bei numerischen Werten (z.B. PM10, Temperatur). Bei Warnstufen/Texten wird automatisch „Worst Case“ verwendet.
      </div>

      <div class="sep"></div>

      <div class="sectionTitle">Ortssuche</div>
      <div class="row" style="margin-top:6px;">
        <label>Stadt</label>
        <input id="citySearch" list="cityList" placeholder="z.B. Graz, Wien, Krems ..." />
        <datalist id="cityList"></datalist>
      </div>

      <div class="row">
        <button class="btn" id="btnSearch">Suchen</button>
        <button class="btn" id="btnReset">Reset</button>
      </div>

      <div class="sep"></div>

      <div class="row">
        <label>Kartenauswahl</label>
        <select id="basemapSelect"></select>
      </div>

      <div style="margin-top:8px;">
        <button class="linkBtn" id="btnDisclaimer" type="button">Hinweis / Disclaimer</button>
      </div>
    </div>
  </div>

  <div class="modalBackdrop" id="modalBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <h2>Hinweis zur Darstellung</h2>
      <p>
        Die Flächenfarben pro Bezirk werden aus den aktuellen Werten der Städte innerhalb des Bezirks abgeleitet
        (z.B. „Worst Case“ = höchster Wert im Bezirk). In Gebirgsregionen kann es lokal deutlich abweichen (Tal vs. Höhenlage).
      </p>
      <p>
        Die Maßnahmen-Texte sind allgemeine Empfehlungen je Warnstufe und ersetzen keine behördlichen Hinweise.
      </p>
      <div class="modalActions">
        <button class="btn" id="btnCloseModal" type="button">Schließen</button>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

  <script>
    // =============================
    // CONFIG
    // =============================
    const GAS_WEBAPP_URL = "https://script.google.com/macros/s/AKfycbz10d2b41DIKuGmKtuN2fJOU8HfIZJv2IIbzQ8lqmFIKTnwdVZTDyAWqdEdVg7Ry7T2uw/exec";

    // Labels erst ab dieser Zoom-Stufe anzeigen
    const CITY_LABEL_MIN_ZOOM = 10;

    // =============================
    // JSONP helper
    // =============================
    function jsonp(url, params) {
      return new Promise((resolve, reject) => {
        const cbName = "cb_" + Math.random().toString(36).slice(2);
        const q = new URLSearchParams(params || {});
        q.set("callback", cbName);

        const script = document.createElement("script");
        script.src = url + (url.includes("?") ? "&" : "?") + q.toString();

        window[cbName] = (data) => {
          delete window[cbName];
          script.remove();
          resolve(data);
        };

        script.onerror = () => {
          delete window[cbName];
          script.remove();
          reject(new Error("JSONP load failed: " + script.src));
        };

        document.body.appendChild(script);
      });
    }

    // =============================
    // Panel toggle + stop pulse
    // =============================
    const panel = document.getElementById("panel");
    const panelToggle = document.getElementById("panelToggle");
    panelToggle.addEventListener("click", () => {
      panel.classList.toggle("collapsed");
      panelToggle.classList.remove("pulse");
      try { localStorage.setItem("panel_pulse_seen", "1"); } catch(e){}
    });
    try{
      if (localStorage.getItem("panel_pulse_seen") === "1") panelToggle.classList.remove("pulse");
    } catch(e){}

    // =============================
    // Disclaimer modal
    // =============================
    const modalBackdrop = document.getElementById("modalBackdrop");
    document.getElementById("btnDisclaimer").addEventListener("click", () => {
      modalBackdrop.style.display = "flex";
      modalBackdrop.setAttribute("aria-hidden", "false");
    });
    document.getElementById("btnCloseModal").addEventListener("click", closeModal);
    modalBackdrop.addEventListener("click", (e) => { if (e.target === modalBackdrop) closeModal(); });
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && modalBackdrop.style.display === "flex") closeModal();
    });
    function closeModal(){
      modalBackdrop.style.display = "none";
      modalBackdrop.setAttribute("aria-hidden", "true");
    }

    // =============================
    // Map + basemaps
    // =============================
    const map = L.map('map', { zoomControl: true }).setView([47.6, 14.2], 7);

    const baseDefs = [
      { id:"osm",  label:"OSM Standard", layer: L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 19, attribution: "&copy; OpenStreetMap" }) },
      { id:"topo", label:"Topo",         layer: L.tileLayer("https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png", { maxZoom: 17, attribution: "&copy; OpenTopoMap" }) },
      { id:"sat",  label:"Satellit",     layer: L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", { maxZoom: 19, attribution: "Tiles &copy; Esri" }) },
    ];
    let activeBase = baseDefs[0].layer.addTo(map);

    const basemapSelect = document.getElementById("basemapSelect");
    baseDefs.forEach(b => {
      const opt = document.createElement("option");
      opt.value = b.id;
      opt.textContent = b.label;
      basemapSelect.appendChild(opt);
    });
    basemapSelect.value = "osm";
    basemapSelect.addEventListener("change", () => {
      const pick = baseDefs.find(x => x.id === basemapSelect.value) || baseDefs[0];
      if (activeBase) map.removeLayer(activeBase);
      activeBase = pick.layer.addTo(map);
    });

    // =============================
    // Metrics
    // =============================
    const METRICS = {
      weather: [
        { id:"t_c_max",         label:"Temperatur (Tagesmaximum)", type:"numeric", unit:"°C" },
        { id:"temp_min_night",  label:"Temperatur (Nachtminimum)", type:"numeric", unit:"°C" },
        { id:"rh_max",          label:"Luftfeuchte (Maximum)",     type:"numeric", unit:"%" },
        { id:"wind_max",        label:"Wind (Böen, Maximum)",      type:"numeric", unit:"km/h" },
        { id:"uv_index",        label:"UV-Index",                  type:"numeric", unit:"" },
        { id:"wetbulb_max",     label:"Feuchtkugel-Temperatur",    type:"numeric", unit:"°C" }
      ],
      air: [
        { id:"pm10",            label:"Feinstaub (PM10)",          type:"numeric", unit:"µg/m³" },
        { id:"pm25",            label:"Feinstaub (PM2.5)",         type:"numeric", unit:"µg/m³" },
        { id:"ozone",           label:"Ozon",                      type:"numeric", unit:"µg/m³" }
      ],
      pollen: [
        { id:"pollen_level",    label:"Pollen – Belastung",        type:"text", unit:"" },
        { id:"pollen_main",     label:"Pollen – Hauptauslöser",    type:"text", unit:"" }
      ],
      warns: [
        { id:"overall_level",   label:"Gesamtwarnstufe",           type:"level", unit:"" },
        { id:"level_heat",      label:"Warnstufe Hitze",           type:"level", unit:"" },
        { id:"level_pm",        label:"Warnstufe Feinstaub",       type:"level", unit:"" },
        { id:"level_uv",        label:"Warnstufe UV",              type:"level", unit:"" },
        { id:"level_pollen",    label:"Warnstufe Pollen",          type:"level", unit:"" },
        { id:"level_ozone",     label:"Warnstufe Ozon",            type:"level", unit:"" }
      ]
    };

    function allMetricInfos(){ return [...METRICS.weather, ...METRICS.air, ...METRICS.pollen, ...METRICS.warns]; }
    function metricInfo(id){ return allMetricInfos().find(m => m.id === id); }

    // =============================
    // State
    // =============================
    let APP_READY = false;
    let currentMetricId = "pm10";
    let currentAggMode = "max";

    let districtsGeo = null;
    let cacheRows = [];
    let measures = {};

    let districtLayer = null;
    let cityLayer = null;
    let labelLayer = null;

    // =============================
    // UI references
    // =============================
    const activeMetricNameEl = document.getElementById("activeMetricName");
    const activeAggPillEl = document.getElementById("activeAggPill");
    const activeLabelPillEl = document.getElementById("activeLabelPill");

    activeLabelPillEl.textContent = `Labels ab Zoom ${CITY_LABEL_MIN_ZOOM}`;

    const metricWeatherRadios = document.getElementById("metricWeatherRadios");
    const metricAirRadios = document.getElementById("metricAirRadios");
    const metricPollenRadios = document.getElementById("metricPollenRadios");
    const metricWarnRadios = document.getElementById("metricWarnRadios");
    const aggRadios = document.getElementById("aggRadios");

    const citySearch = document.getElementById("citySearch");
    const cityList = document.getElementById("cityList");

    // =============================
    // Radio builders
    // =============================
    function buildMetricRadios(container, items, options){
      container.innerHTML = "";
      const name = (options && options.name) ? options.name : "metricMain";

      items.forEach((m) => {
        const id = (options && options.idPrefix ? options.idPrefix : "m_") + m.id;

        const input = document.createElement("input");
        input.type = "radio";
        input.name = name;
        input.id = id;
        input.value = m.id;

        const label = document.createElement("label");
        label.className = "radioLabel";
        label.htmlFor = id;
        label.textContent = m.label;

        container.appendChild(input);
        container.appendChild(label);
      });
    }

    function buildAggRadios(){
      aggRadios.innerHTML = "";

      const defs = [
        { id:"max",  label:"Höchster Wert (Worst Case)", hint:"zeigt den kritischsten Messwert im Bezirk" },
        { id:"mean", label:"Durchschnitt", hint:"mittlere Belastung im Bezirk" },
        { id:"min",  label:"Niedrigster Wert", hint:"bestmöglicher Messwert im Bezirk" }
      ];

      defs.forEach((d) => {
        const id = "a_" + d.id;

        const input = document.createElement("input");
        input.type = "radio";
        input.name = "aggMode";
        input.id = id;
        input.value = d.id;

        const label = document.createElement("label");
        label.className = "radioLabel";
        label.htmlFor = id;
        label.innerHTML = `${d.label}<small>${d.hint}</small>`;

        aggRadios.appendChild(input);
        aggRadios.appendChild(label);
      });

      const pre = document.querySelector(`input[name="aggMode"][value="${currentAggMode}"]`);
      if (pre) pre.checked = true;
    }

    // Build radios (all metrics share name="metricMain" => immer klar: genau 1 aktiv)
    buildMetricRadios(metricWeatherRadios, METRICS.weather, { name:"metricMain", idPrefix:"mw_" });
    buildMetricRadios(metricAirRadios, METRICS.air, { name:"metricMain", idPrefix:"ma_" });
    buildMetricRadios(metricPollenRadios, METRICS.pollen, { name:"metricMain", idPrefix:"mp_" });
    buildMetricRadios(metricWarnRadios, METRICS.warns, { name:"metricMain", idPrefix:"mx_" });

    buildAggRadios();

    // Preselect default
    const preMetric = document.querySelector(`input[name="metricMain"][value="${currentMetricId}"]`);
    if (preMetric) preMetric.checked = true;

    // =============================
    // Active selection display
    // =============================
    function aggLabel(mode){
      if (mode === "mean") return "Bezirkswert: Durchschnitt";
      if (mode === "min") return "Bezirkswert: Niedrigster Wert";
      return "Bezirkswert: Höchster Wert (Worst Case)";
    }

    function updateActiveHeader(){
      const info = metricInfo(currentMetricId);
      activeMetricNameEl.textContent = info ? info.label : currentMetricId;
      activeAggPillEl.textContent = aggLabel(currentAggMode);
    }

    function updateAggAvailability(){
      const info = metricInfo(currentMetricId);
      const isNumeric = info && info.type === "numeric";

      if (!isNumeric) {
        // Aggregation macht hier keinen Sinn -> fix max (Worst Case)
        currentAggMode = "max";
        const maxRadio = document.querySelector(`input[name="aggMode"][value="max"]`);
        if (maxRadio) maxRadio.checked = true;

        aggRadios.classList.add("disabled");
        activeAggPillEl.classList.add("disabled");
        activeAggPillEl.textContent = "Bezirkswert: Worst Case (automatisch)";
      } else {
        aggRadios.classList.remove("disabled");
        activeAggPillEl.classList.remove("disabled");
        activeAggPillEl.textContent = aggLabel(currentAggMode);
      }
    }

    function setActiveMetric(id){
      currentMetricId = id;
      updateAggAvailability();
      updateActiveHeader();
      if (APP_READY) renderAll();
    }

    function setAggMode(mode){
      currentAggMode = mode;
      updateAggAvailability();
      updateActiveHeader();
      if (APP_READY) renderAll();
    }

    // Listeners
    document.addEventListener("change", (e) => {
      if (!e.target) return;

      if (e.target.name === "metricMain") {
        setActiveMetric(e.target.value);
      }
      if (e.target.name === "aggMode") {
        setAggMode(e.target.value);
      }
    });

    // Init header
    updateAggAvailability();
    updateActiveHeader();

    // =============================
    // Helpers
    // =============================
    function levelColor(lvl){
      switch(String(lvl || "").toUpperCase()){
        case "RED": return "#d32f2f";
        case "ORANGE": return "#f57c00";
        case "YELLOW": return "#fbc02d";
        case "GREEN": return "#388e3c";
        default: return "#9e9e9e";
      }
    }
    function chipClass(v){
      const s = String(v || "").toUpperCase();
      if (s === "GREEN" || s === "YELLOW" || s === "ORANGE" || s === "RED") return s;
      return "GREY";
    }
    function escapeHtml(s){
      return String(s || "")
        .replace(/&/g,"&amp;")
        .replace(/</g,"&lt;")
        .replace(/>/g,"&gt;");
    }
    function formatNum(v){
      if (v == null || !isFinite(v)) return "–";
      return (Math.round(v*10)/10).toString();
    }
    function measuresText(cat, lvl){
      const C = String(cat||"").toUpperCase();
      const L = String(lvl||"").toUpperCase();
      if (!C || !L) return "";
      return (measures[C] && measures[C][L]) ? measures[C][L] : "";
    }
    function valueLabel(metricId, v){
      const info = metricInfo(metricId);
      if (!info) return "–";
      if (v == null) return "–";
      if (info.type === "numeric") return formatNum(v) + (info.unit ? " " + info.unit : "");
      return String(v);
    }

    // =============================
    // District aggregation
    // =============================
    function aggregateForDistrict(feature, rows, metricId, aggMode){
      const info = metricInfo(metricId);
      if (!info) return null;

      const t = feature && feature.geometry ? feature.geometry.type : "";
      if (t !== "Polygon" && t !== "MultiPolygon") return null;

      const vals = [];
      for (const r of rows){
        if (!isFinite(r.lat) || !isFinite(r.lon)) continue;
        const pt = turf.point([r.lon, r.lat]);

        let inside = false;
        try{ inside = turf.booleanPointInPolygon(pt, feature); } catch(e){ inside = false; }
        if (!inside) continue;

        const v = r[metricId];
        if (v == null || v === "") continue;
        vals.push(v);
      }

      if (!vals.length) return null;

      if (info.type === "level"){
        const rank = { GREEN:0, YELLOW:1, ORANGE:2, RED:3 };
        let worst = "GREEN";
        for (const x of vals){
          const k = String(x||"").toUpperCase();
          if ((rank[k] ?? -1) > (rank[worst] ?? -1)) worst = k;
        }
        return worst;
      }

      if (info.type === "numeric"){
        const nums = vals.map(x => Number(x)).filter(n => isFinite(n));
        if (!nums.length) return null;
        if (aggMode === "min") return Math.min(...nums);
        if (aggMode === "mean") return nums.reduce((a,b)=>a+b,0)/nums.length;
        return Math.max(...nums);
      }

      // text: kein sinnvoller Bezirkswert -> null
      return null;
    }

    function numericColor(v){
      if (v == null || !isFinite(v)) return "#9e9e9e";
      if (v >= 100) return "#6a1b9a";
      if (v >= 60) return "#d32f2f";
      if (v >= 40) return "#f57c00";
      if (v >= 20) return "#fbc02d";
      return "#388e3c";
    }

    // =============================
    // City labels: show only at zoom >= CITY_LABEL_MIN_ZOOM
    // =============================
    function shouldShowCityLabels(){
      return map.getZoom() >= CITY_LABEL_MIN_ZOOM;
    }

    function updateLabelVisibility(){
      if (!labelLayer) return;
      const show = shouldShowCityLabels();
      const has = map.hasLayer(labelLayer);

      if (show && !has) labelLayer.addTo(map);
      if (!show && has) map.removeLayer(labelLayer);
    }

    map.on("zoomend", updateLabelVisibility);

    // =============================
    // Render
    // =============================
    function renderAll(){
      if (!districtsGeo || !cacheRows.length) return;

      const metricId = currentMetricId;
      const info = metricInfo(metricId);

      // AggMode für non-numeric ignorieren (wird ohnehin fix auf max gesetzt)
      const aggMode = currentAggMode;

      if (districtLayer) districtLayer.remove();
      if (cityLayer) cityLayer.remove();
      if (labelLayer) {
        if (map.hasLayer(labelLayer)) map.removeLayer(labelLayer);
        labelLayer.remove();
      }

      districtLayer = L.geoJSON(districtsGeo, {
        style: (feature) => {
          const v = aggregateForDistrict(feature, cacheRows, metricId, aggMode);

          let fill = "#9e9e9e";
          if (info && info.type === "level") fill = levelColor(v);
          if (info && info.type === "numeric") fill = numericColor(v);

          return { color:"#444", weight:1, fillColor:fill, fillOpacity:0.45 };
        },
        onEachFeature: (feature, layer) => {
          const name = feature.properties && (feature.properties.name || feature.properties.NAME)
            ? (feature.properties.name || feature.properties.NAME)
            : "Bezirk";
          const v = aggregateForDistrict(feature, cacheRows, metricId, aggMode);
          const label = info ? info.label : metricId;

          let txt = "–";
          if (v != null) txt = valueLabel(metricId, v);

          // Für Text-Metriken bleibt Bezirkswert leer – Popup trotzdem sauber
          layer.bindPopup(`<strong>${escapeHtml(name)}</strong><br>${escapeHtml(label)}: <strong>${escapeHtml(String(txt))}</strong>`);
        }
      }).addTo(map);

      cityLayer = L.layerGroup().addTo(map);
      labelLayer = L.layerGroup(); // wird je nach Zoom eingeblendet

      cacheRows.forEach(r => {
        const c = L.circleMarker([r.lat, r.lon], {
          radius: 6, weight: 1, color: "#222",
          fillColor: levelColor(r.overall_level), fillOpacity: 0.9
        });

        c.bindPopup(buildCityPopup(r), { maxWidth: 360 });
        c.addTo(cityLayer);

        const icon = L.divIcon({
          className: "cityLabelWrap",
          html: `<span class="cityLabel">${escapeHtml(r.city)}</span>`,
          iconSize: [1,1]
        });
        L.marker([r.lat, r.lon], { icon, interactive:false, keyboard:false }).addTo(labelLayer);
      });

      updateLabelVisibility();
    }

    function buildCityPopup(r){
      const chips = `
        <div style="margin:8px 0 6px;">
          <span class="chip ${chipClass(r.overall_level)}">Gesamt: ${escapeHtml(r.overall_level||"-")}</span>
        </div>
        <div style="margin:0 0 8px;">
          <span class="chip ${chipClass(r.level_heat)}">Hitze: ${escapeHtml(r.level_heat||"-")}</span>
          <span class="chip ${chipClass(r.level_pm)}">Feinstaub: ${escapeHtml(r.level_pm||"-")}</span>
          <span class="chip ${chipClass(r.level_uv)}">UV: ${escapeHtml(r.level_uv||"-")}</span>
          <span class="chip ${chipClass(r.level_pollen)}">Pollen: ${escapeHtml(r.level_pollen||"-")}</span>
          <span class="chip ${chipClass(r.level_ozone)}">Ozon: ${escapeHtml(r.level_ozone||"-")}</span>
        </div>
      `;

      const rows = [
        ["Temperatur (Tagesmaximum)", valueLabel("t_c_max", r.t_c_max)],
        ["Temperatur (Nachtminimum)", valueLabel("temp_min_night", r.temp_min_night)],
        ["Luftfeuchte (Maximum)", valueLabel("rh_max", r.rh_max)],
        ["Wind (Böen, Maximum)", valueLabel("wind_max", r.wind_max)],
        ["UV-Index", valueLabel("uv_index", r.uv_index)],
        ["Feinstaub (PM10)", valueLabel("pm10", r.pm10)],
        ["Feinstaub (PM2.5)", valueLabel("pm25", r.pm25)],
        ["Ozon", valueLabel("ozone", r.ozone)],
        ["Feuchtkugel-Temperatur", valueLabel("wetbulb_max", r.wetbulb_max)],
        ["Pollen – Hauptauslöser", r.pollen_main || "–"],
        ["Pollen – Belastung", r.pollen_level || "–"]
      ].map(([k,v]) => `
        <tr>
          <td style="padding:3px 10px 3px 0;color:#666; white-space:nowrap;">${escapeHtml(k)}</td>
          <td style="padding:3px 0;"><strong>${escapeHtml(String(v))}</strong></td>
        </tr>
      `).join("");

      const mHeat = measuresText("HEAT", r.level_heat);
      const mPm   = measuresText("PM", r.level_pm);
      const mUv   = measuresText("UV", r.level_uv);
      const mPol  = measuresText("POLLEN", r.level_pollen);
      const mOz   = measuresText("OZONE", r.level_ozone);

      const mHtmlParts = [];
      if (mHeat) mHtmlParts.push(`<div><strong>Hitze:</strong> ${escapeHtml(mHeat)}</div>`);
      if (mPm)   mHtmlParts.push(`<div><strong>Feinstaub:</strong> ${escapeHtml(mPm)}</div>`);
      if (mUv)   mHtmlParts.push(`<div><strong>UV:</strong> ${escapeHtml(mUv)}</div>`);
      if (mPol)  mHtmlParts.push(`<div><strong>Pollen:</strong> ${escapeHtml(mPol)}</div>`);
      if (mOz)   mHtmlParts.push(`<div><strong>Ozon:</strong> ${escapeHtml(mOz)}</div>`);

      const measuresBlock = mHtmlParts.length
        ? `<div class="sep"></div>
           <div style="font-size:12px;line-height:1.4;">
             <strong>Maßnahmen</strong>
             ${mHtmlParts.join("")}
           </div>`
        : "";

      return `
        <div class="popupBody" style="min-width:300px;">
          <div style="font-size:15px;"><strong>${escapeHtml(r.city)}</strong></div>
          ${chips}
          <table class="popupTable" style="border-collapse:collapse;font-size:12px;margin-top:2px;">${rows}</table>
          ${measuresBlock}
        </div>
      `;
    }

    function fillCityList(rows){
      cityList.innerHTML = "";
      rows.map(r => r.city).sort((a,b)=>a.localeCompare(b,"de")).forEach(name => {
        const opt = document.createElement("option");
        opt.value = name;
        cityList.appendChild(opt);
      });
    }

    function zoomToCity(name){
      const q = String(name || "").trim().toLowerCase();
      if (!q) return;

      const hit = cacheRows.find(r => String(r.city||"").trim().toLowerCase() === q);
      if (!hit) { alert("Stadt nicht gefunden: " + name); return; }
      map.setView([hit.lat, hit.lon], Math.max(map.getZoom(), CITY_LABEL_MIN_ZOOM)); // bei Suche direkt in Label-Zoom springen
    }

    document.getElementById("btnSearch").addEventListener("click", () => zoomToCity(citySearch.value));
    citySearch.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter") { ev.preventDefault(); zoomToCity(citySearch.value); }
    });
    document.getElementById("btnReset").addEventListener("click", () => map.setView([47.6, 14.2], 7));

    // =============================
    // BOOT
    // =============================
    async function boot(){
      try{
        // 1) Bezirke aus GAS laden (JSONP)
        const gj = await jsonp(GAS_WEBAPP_URL, { action: "bezirke_geojson" });
        if (!gj || gj.type !== "FeatureCollection") throw new Error("bezirke_geojson: kein FeatureCollection erhalten");

        districtsGeo = {
          type: "FeatureCollection",
          features: (gj.features || []).filter(f =>
            f && f.geometry && (f.geometry.type === "Polygon" || f.geometry.type === "MultiPolygon")
          )
        };

        // 2) Cache rows
        const cache = await jsonp(GAS_WEBAPP_URL, { action: "cache" });
        if (!cache || !cache.ok) throw new Error((cache && cache.error) ? cache.error : "cache failed");

        cacheRows = (cache.rows || []).map(r => {
          const out = { ...r };
          out.lat = Number(String(r.lat).replace(",", "."));
          out.lon = Number(String(r.lon).replace(",", "."));
          return out;
        }).filter(r => isFinite(r.lat) && isFinite(r.lon));

        fillCityList(cacheRows);

        // 3) Measures (optional)
        try{
          const m = await jsonp(GAS_WEBAPP_URL, { action: "measures" });
          if (m && m.ok && m.measures) measures = m.measures;
        } catch(e){
          measures = {};
        }

        APP_READY = true;
        renderAll();

      } catch(e){
        console.error(e);
        alert("Fehler: " + (e && e.message ? e.message : String(e)));
      }
    }

    boot();
  </script>
</body>
</html>
